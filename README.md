# java-lotto

로또 미션 저장소

## 우아한테크코스 코드리뷰

- [온라인 코드 리뷰 과정](https://github.com/woowacourse/woowacourse-docs/blob/master/maincourse/README.md)

---

## 기능 요구 사항

- [x] 구입 금액을 입력받는다.
    - [x] 숫자를 입력받는다.
    - [x] <예외> 숫자 외 다른 문자를 입력한다.
    - [x] <예외> 공백 또는 빈 문자열을 입력한다.
    - [x] <예외> 음수를 입력한다.
- [x] 구입 금액으로 로또를 살 수 없으면 프로그램을 종료한다.
- [x] 수동으로 구매할 로또 수를 입력받는다.
    - [x] 숫자를 입력받는다.
    - [x] <예외> 숫자 외 다른 문자를 입력한다.
    - [x] <예외> 공백 또는 빈 문자열을 입력한다.
    - [x] <예외> 음수를 입력한다.
- [x] 수동으로 구매할 횟수만큼 로또 번호를 입력받는다.
    - 1 ~ 45 사이의 중복되지 않는 숫자 6개를 ‘,‘ 로 구분하여 적는다. (컴마간의 띄어쓰기는 허용한다.)
- [x] 로또를 구매한다.
    - 로또 1장의 가격은 1000원이다.
    - [x] 먼저 수동으로 구매가 가능한 만큼 구매한다.
        - 구매할 만큼 반복한다.
        - 구매한 만큼 구입 금액을 뺀다.
    - 수동으로 로또를 구매한 뒤 남은 구입 금액은 자동으로 로또를 구매한다.
        - 1 ~ 45의 숫자를 무작위로 중복 없이 6개 뽑는다.
    - 구매한 로또의 6개의 숫자를 오름차순으로 정렬한다.
    - [x] <예외> 숫자가 6개가 아니다.
    - [x] <예외> 중복된 숫자가 입력된다.
    - [X] <예외> 숫자가 1 ~ 45 사이가 아니다.
- [x] 로또를 출력한다.
    - 수동으로 구매한 로또를 먼저 출력한다.
- [x] 당첨 번호를 입력한다.
    - [x] 1 ~ 45 사이의 중복되지 않는 숫자 6개를 ‘,‘ 로 구분하여 적는다. (컴마간의 띄어쓰기는 허용한다.)
    - [x] <예외> 입력된 숫자가 6개가 아니다.
    - [x] <예외> 중복된 숫자가 입력된다.
    - [x] <예외> 숫자가 1 ~ 45 사이가 아니다.
    - [x] <예외> 숫자 외 다른 문자를 입력한다.
    - [x] <예외> 공백 또는 빈 문자열을 입력한다.
- [x] 보너스볼을 입력한다.
    - [x] 당첨번호와 중복되지 않은 1 ~ 45 까지의 숫자를 입력한다.
    - [x] <예외> 숫자가 1 ~ 45 사이가 아니다.
    - [x] <예외> 앞서 입력한 당첨번호와 중복된 숫자가 입력된다.
    - [x] <예외> 숫자 외 다른 문자를 입력한다.
    - [x] <예외> 공백 또는 빈 문자열을 입력한다.
- [x] 당첨 통계를 낸다.
    - [x] 구매한 로또번호와 당첨번호, 보너스 볼을 비교한다.
        - 3개가 일치한 경우 5000원이 당첨된다.
        - 4개가 일치한 경우 50000원(5만원)이 당첨된다.
        - 5개가 일치할 경우 1500000원(150만원)이 당첨된다.
        - 5개가 일치하고 보너스 볼이 일치한 경우 30000000원(3000만원)이 당첨된다.
        - 6개가 일치한 경우 2000000000원(20억원)이 당첨된다.
- [x] 당첨 통계를 출력한다.
    - [x] <예외> LottoResults에 null로 생성한다.
- [x] 수익률을 낸다.
    - 수익률은 총 당첨 금액 / 구입 금액 이다.
    - 소숫점 2자리까지 출력하고 나머지는 버린다.
- [x] 수익률을 출력한다.

---

## 1단계 자동 피드백, 수정

- [x] `ResultView`의 `printResults`에서 `(기준이 1이기 때문에 결과적으로 손해라는 의미임)`문구가 꼭 필요한가?
    - 고정적으로 이 문구를 포함하면 1을 넘어도 이 문구가 출력되기 때문에 사용자 입장에서 볼 때 결과가 잘못된건지 이 문구가 잘못된건지 모를 수 있다.
    - 클라이언트 사이드를 고려하는 것도 굉장히 중요한 포인트가 된다!
- [x] VO 패키지에 다른 것들이 섞여 있는 것 같다. VO의 정의가 무엇일까?
    - [x] VO가 아닌 클래스를 VO 패키지 밖으로 이동
    - [x] VO라면 꼭 고려해야 할 것이 무엇이 있을까?
        - VO 클래스들에 equals, hashCode, toString 재정의 추가
        - [자동차 미션을 하며 생각해본 VO](https://github.com/woowacourse/java-racingcar/pull/387#issuecomment-1046303133)
        - 이전 미션을 하면서 처음으로 VO에 대해 생각해본적이 있는데 이때 VO는 불변하고 equals와 hashCode를 재정의해야한다는 것을 보고도 잊어버린것같다.
        - 다시 한번 간단하게 정리
            - 왜 불변해야하는가? 의도하지 않은 수정(사이드 이펙트)을 막기 위해
            - 왜 equals, hashCode를 재정의 해야하는가? 동등성 검사를 위해(하다보면서 알게 되었는데 contains 같은것들도 equals를 재정의하지 않으면 제대로 동작하지 않음)
            - 왜 validate를 해야하는가? VO가 가진 값을 VO 내부에서 검증하여 응집도가 높아진다.
- [x] 500원을 입력하면 수익률이 NaN이 나오는데 어떻게 해결할 수 있을까요?
    - 이 문제를 해결하기 위한 방법은 세 가지정도 있을 것 같다.
        - 1000원 미만의 금액이 입력되면 예외 발생
        - 1000원 미만의 금액이 입력되면 구매한 로또의 수가 0이므로 당첨번호를 입력받지 않고 종료/예외 발생
        - 수익률을 계산할 때 오류가 발생하지 않도록 수정(기존엔 0으로 나누어 발생한 문제)
    - 로또를 사지 못하는 상황에서 생각할 것들
        - 돈이 부족하여 로또를 사지 못하면 (예외 발생 <-> 0개 구매 후 진행)
        - 로또를 0개 가지고 있을 때 (당첨 번호 입력 <-> 미입력)
        - 로또를 0개 가지고 있을 때 (당첨 통계 출력 <-> 미출력)
    - 결국은 돈이 부족하여도 0개를 구매한 후 당첨 번호와 통계는 입/출력하지 않고 종료하도록 수정하였다.
    - 돈이 부족한 것은 입력에서 금액을 음수/문자로 입력하는 등 예외를 발생시킬 상황은 아니라고 생각하게 되었고, 로또의 수가 0개라면 당첨이 될 수 없기 때문에 당첨 번호를 입력받거나 결과를 출력하지 않았다.
- [x] `Lottos`에서 `purchase()`의 과정이 자연스러울까?
    - `Lottos`를 만들고 그곳에서 구매를 하는 것 vs 구매를 하여 그것으로 `Lottos`를 만드는 것 무엇이 자연스러울까?
    - 기존 Lottos의 `purchase()`는 Lottos에 새로운 Lotto를 추가하는 방식이다. 지금 다시 생각해보니 이것은 setter나 add와 같이 Lottos의 상태를 변경하게 되어 불변해야하는
      조건을 만족하지 않는 것 같다.
    - 그래서 Lottos의 `purchase()`를 사용하는 LottoGame에서 `List<Lotto>`를 만들고 이것을 이용하여 Lottos를 만드는 것이 더 적절한 것 같다.
    - 수정 하면서 Lottos가 가지던 로또의 가격 상수를 LottoGame이 가지게 되었다. 이것도 Lottos가 아닌 LottoGame이 가지는 것이 더 자연스러운 것 같다.
        - LottoResults의 수익률 계산을 하는 코드에서 로또의 가격을 하드코딩했다. 이 코드를 LottoGame이 가진 로또 가격을 주어 수정했다.
- [x] `LottoGenerator`에서 사용하는 상수는 다른 클래스가 가져야 할 상수가 아닐까?
    - 이미 더 적절한 곳에 상수로 정의되어있지만 private이기 때문에 사용하지 못했었다. 이것을 사용하기위해 getter를 사용할까 생각했었는데 Integer.MAX_VALUE처럼 public 상수를
      사용하도록 수정했다.
- [x] `WinningNumber`의 `List<LottoNumber>`는 이미 있는 일급 컬렉션을 사용해보면 어떨까?
    - `WinningNumber`의 `validateLottoNumbersDuplication()`은 `Lotto`에서 체크하고 있는 validate와 다른가?
    - 완전 같은 기능이다. `List<LottoNumber>`를 Lotto 일급 컬렉션을 사용하면 WinningNumber가 하던 일부 검증을 Lotto가 하게된다.
- [x] `LottoPrize`에서 `checkMatches`의 조건 분기를 합칠 수 있지 않을까?
    - [x] 수정한 stream식이 너무 복잡하지 않을까? 특정 조건을 early return을 하는 방식이면 훨씬 쉽게 해결이 될 것 같다.
- [x] LottoGame의 `purchase()`를 테스트하기위해 LottoGenerator를 인터페이스 분리, 전략 패턴 적용
- [x] 테스트의 핵심 역할 중 하나는 프로덕션 코드에 대한 명세(문서)라는 것을 고려하며 전체적으로 테스트를 다시 확인해보자!
    - **지금은 명세가 잘 나타나고 이해하기 쉬운 테스트를 만드는 것에 집중하자.**
    - 테스트를 작성할 때 명세는 추상적인 표현보다 구체적인 문장으로 표현하는 게 좋다.
    - 테스트를 보면 해당 코드의 동작, 기능 들을 알 수 있어야 한다.
    - 명세에 맞는 테스트가 제대로 되는지도 확인해보면 좋을 것 같다.
- [x] `LottosTest`의 `confirmWinnings_test`와 같은 방식보다 좋은 테스트 방식이 있을까?
    - private 메서드가 너무 과하게 생기는 것 같다.
    - 전략 패턴으로 인터페이스를 분리하여 로또 번호가 (1,2,3,4,5,6)으로 고정인 CustomLottoGenerator를 만들어 테스트한다.
- [x] 테스트는 무엇을 어떻게 테스트하는지 알기 쉬워야한다.
    - Test에서 CustomLottoGenerator를 만들어 보는 시도는 좋았지만 Generator에 들어가야 어떤 데이터로 테스트하는지 확인할 수 있다.
    - LottosTest에서는 CustomLottoGenerator를 쓰지 않고 `List<LottoNumber`를 직접 작성하도록 수정해 조금 더 코드를 이해하기 쉽게 수정했다.
    - LottoGameTest에서는 `purchase()`와 `confirmWinnings()`를 테스트하기 위해 CustomLottoGenerator를 사용한것이라 수정하지 않아도 될 것 같다.
- [x] 더 이해하기 쉬운 테스트를 위해 리펙토링을 해보자!
    - 간단한 테스트가 아니라 코드가 조금 긴 테스트에서 given-when-then을 적용해봤다. 다른 사람이 볼 때 어느것을 어떻게 테스트하는지 확인할 때 더 좋을 수도 있을 것 같아서 적용해봤지만 좋은게
      맞는지는 다른 크루들과 더 이야기해봐야 알 것 같다.
    - 전역 변수와 BeforeEach를 사용하던 코드에서 사용하지 않는 것으로 수정했다. 테스트에 직접 연관이 되는 것들이 아니면 사용해도 될 것 같지만 나는 단지 여러 테스트에서 일부 공통적으로 쓰이는것이
      있어서 적용했던 것 같다. 그리고 꼭 필요한게 아닌데 전역 변수로 만들어 사용하게 되면 다른 테스트를 만들 때 그 전역 변수를 확인하고 테스트를 만들어야 한다는 문제도 있는 것 같다.
    - 테스트를 하다보니 어쩔 수 없이 메소드가 10줄이 넘어 요구조건을 어기게 되었다. 테스트에서도 메서드 10줄 요구조건을 맞추기 위해 메서드 분리를 하면 값이나 동작을 알기위해 메서드를 이동하면서 확인해야할
      것 같은데 그래도 메서드를 분리하는게 좋을까?
        - 테스트는 조금 길어지더라도 메서드에 대한 명세를 잘 나타내고 읽기 쉬우면 괜찮을 것 같다. 우선은 그것에 집중해보자.
    - when에는 테스트하려는 동작만을 최소한으로 실행하도록 작성하는게 좋은 것 같다. 따라서 실행을 하고 검증을 위해 getter를 쓴다면 그 getter는 then에 위치하는게 적절하다.
- getter를 이용한 테스트
    - getter는 데이터가 필요한 시점에 사용할 수밖에 없기 때문에 테스트에서도 getter를 사용한다.
    - `LottosTest`의 경우도 내부의 데이터가 잘 생성되었는지 검증하려면 어쩔 수 없이 사용할 것 같다.
    - 그래서 미래에 사용할 가능성이 크다면 getter를 미리 만들어도 괜찮을 수도 있다.
- [x] Lotto를 만들 때 동일한 LottoNumber라면 같은 인스턴스를 사용할 수 있도록 캐싱을 해보면 어떨까요?
    - 힌트
        - 캐싱할 자료구조를 고민한다.
        - 어떤 숫자로 LottoNumber 생성 요청이 왔을 때, 해당 자료구조에 기존에 만들어둔 인스턴스가 있는지 확인하고, 있으면 그대로 반환, 없으면 새로 생성한 후 캐싱한 뒤 반환한다.
        - 캐싱한 자료구조를 위한 별도 클래스 (pool)를 만들어도 좋다. (혹은 LottoNumber 내부에 있어도 좋다.)
        - 위 경로 외에 LottoNumber를 생성할 수 있는 다른 방법이 있어서는 안 된다. (캐싱하는 의미가 없어지므로)
- [x] Collections.EMPTY_LIST, Collections.emptyList()의 사용을 지양해야하는 이유는 무엇일까?
    - [EmptyList() vs new](https://www.baeldung.com/java-collections-emptylist-new-list)
    - 지금은 빈 불변 리스트를 사용하기 때문에 EmptyList를 사용할 수도 있다. 하지만 프로그램에 절대는 거의 없기 때문에 언젠가 리스트를 사용하게
      되면 `UnsupportedOperationException`이 발생한다. `new ArrayList<>()`를 사용하면 지금이나 미래나 크게 문제될 부분이 없다.
    - EmptyList와 new ArrayList<>()의 차이점은 불변과 가변이다.
    - 나는 데이터가 없는 List를 사용하기 위해 Collections.EMPTY_LIST를 사용했다. `new ArrayList<>()`도 데이터가 없는 List를 반환한다.
    - 하지만 이 List는 구매를 할 수 없는 경우에 실행되는 메서드에서 사용된다. 그래서 이후에도 데이터 추가 등 수정이 없어야 한다고 생각해서 Collections.EMPTY_LIST를 사용했었다.
    - Collections.EMPTY_LIST()를 지양해야 하는 이유 중 하나가 제네릭과 관련될 수도 있다고 생각했지만 `Collections.<>emptyList()` 또는 `List.<>of()`으로
      제네릭 설정도 되는 것 같다. (List가 데이터를 가질 수 없기 때문에 제네릭이 중요하지 않을 수도 있지만 그래도 잘못설정하면 컴파일이 되지 않는다.)
- [x] 변수명으로 유추하려면 할 수 있는 상황이라도 메서드를 통해 추상화하면 더 읽기 좋은 코드가 될 수 있지 않을까?
    - 추측할 수 있는 상황이라도 메서드를 분리하면 메서드 이름으로 조금 더 명확하게 코드의 의도를 전달할 수 있을 것 같다.
- [x] 공백 라인도 중요한 의미를 가지게 되는데 문맥에 맞게 공백라인을 사용해보면 좋을 것 같다.
    - `purchase()`메서드를 다시보니 10줄이 다 붙어있다보니 확실히 잘 읽히지 않는 느낌이었다.
    - 큰 단락을 나눈다는 느낌으로 공백 라인을 만들어보니 더 잘 읽히는 것 같다. 코드가 잘 읽히지 않는다면 적절하게 공백 라인을 써보자.
- [x] LottoPrize에서 2등을 Early return을 하는데 filter로 다시 검사해야할까?
    - early return로 2등인 경우를 판별하지만 stream식에서 `values()`로 검사를 하다보니 2등인 경우에 다시 filter에 걸리게 된다.
    - `.filter(prize -> prize.lottoNumberMatchCount == lottoNumberMatchCount)`로 2등과 3등이 모두 true가 나오기 때문이다.
    - 그 상태로 `findFirst()`를 하게되면 Enum의 순서가 3등, 2등 순으로 되어있으면 첫번째는 3등을 반환하지만 Enum의 순서가 바뀌면 2등이 출력되게 된다.
    - 결국 첫번째 filter에서 2등과 3등을 제대로 구분하지 못하기 때문에 발생한 문제이다. 이 문제를 해결하기 위해 세 가지 방법을 생각해봤다.
        - LottoPrize.values()에서 2등을 빼고 stream()식을 실행한다.
        - 절대 enum의 순서를 바꾸지 않는다.
        - early return으로 확인하는 2등은 stream()에서 무조건 걸러낸다.
    - 3번째 방법이 가장 이해하기 쉽고 이후에 발생할 Enum에 수정이 발생해도 문제가 발생할 가능성이 적다고 생각했다.
- [x] LottoController의 `purchase()`와 `purchaseNothing()`을 합칠 수 있지않을까?
